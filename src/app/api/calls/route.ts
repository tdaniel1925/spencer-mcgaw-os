import { NextResponse } from "next/server";
import { db } from "@/db";
import { calls } from "@/db/schema";
import { desc } from "drizzle-orm";

export async function GET() {
  try {
    // Fetch calls from database, ordered by newest first
    const callRecords = await db
      .select()
      .from(calls)
      .orderBy(desc(calls.createdAt))
      .limit(100);

    // Transform database records to match frontend CallRecord type
    const transformedCalls = callRecords.map((call) => {
      // Parse metadata for AI analysis if present
      const metadata = call.metadata as Record<string, unknown> | null;
      const analysis = metadata?.analysis as Record<string, unknown> | null;

      // Extract line/user info from participants (GoTo Connect)
      const participants = metadata?.participants as Array<Record<string, unknown>> | undefined;
      let lineUser: { name?: string; number?: string; extension?: string; userId?: string; type?: string } | undefined;

      if (participants && participants.length > 0) {
        // Find the internal user (non-originator in inbound, or originator in outbound)
        const internalUser = participants.find(p =>
          call.direction === "inbound" ? !p.originator : p.originator
        ) || participants[0];

        if (internalUser) {
          lineUser = {
            name: internalUser.name as string | undefined,
            number: internalUser.number as string | undefined,
            extension: internalUser.extension as string | undefined,
            userId: internalUser.id as string | undefined,
            type: internalUser.type as string | undefined,
          };
        }
      }

      // Extract actual call timestamps from metadata (GoTo provides these)
      // Fall back to createdAt if not available
      const callCreated = metadata?.callCreated as string | undefined;
      const callEnded = metadata?.callEnded as string | undefined;
      const callAnswered = metadata?.callAnswered as string | undefined;

      // Use the actual call start time from GoTo, or fall back to DB created_at
      const callStartedAt = callAnswered || callCreated
        ? new Date(callAnswered || callCreated as string)
        : call.createdAt;

      const callEndedAt = callEnded ? new Date(callEnded) : undefined;

      return {
        id: call.id,
        source: "phone_call" as const,
        sourceProvider: (metadata?.sourceProvider as string) || "vapi",
        callerPhone: call.callerPhone || "Unknown",
        callerName: call.callerName || undefined,
        callerEmail: undefined,
        lineUser,
        callStartedAt,
        callEndedAt,
        durationSeconds: call.duration || 0,
        direction: call.direction as "inbound" | "outbound",
        recordingUrl: call.recordingUrl || undefined,
        transcript: call.transcription || undefined,
        matchedClientId: call.clientId || undefined,
        status: call.status === "completed" ? "reviewed" : "new",
        createdAt: call.createdAt,
        updatedAt: call.createdAt,
        vapiCallId: call.vapiCallId,
        // AI Analysis from metadata
        aiAnalysis: analysis ? {
          summary: (analysis.summary as string) || call.summary || "Call recorded",
          keyPoints: (analysis.keyPoints as string[]) || [],
          category: (analysis.category as string) || call.intent || "other",
          sentiment: (analysis.sentiment as string) || call.sentiment || "neutral",
          urgency: (analysis.urgency as string) || "medium",
          extractedInfo: {
            reason: (analysis.summary as string) || call.summary || "",
            questions: [],
            mentionedAmounts: [],
            mentionedDates: [],
          },
          suggestedActions: ((analysis.suggestedActions as string[]) || []).map((action, idx) => ({
            id: `action-${call.id}-${idx}`,
            type: "create_task" as const,
            label: action,
            description: action,
            priority: "medium" as const,
            autoGenerated: true,
          })),
          confidence: (metadata?.confidence as number) || 0.85,
          analyzedAt: new Date(metadata?.parsedAt as string || call.createdAt),
        } : call.summary ? {
          summary: call.summary,
          keyPoints: [],
          category: call.intent || "other",
          sentiment: call.sentiment || "neutral",
          urgency: "medium",
          extractedInfo: {
            reason: call.summary,
            questions: [],
            mentionedAmounts: [],
            mentionedDates: [],
          },
          suggestedActions: [],
          confidence: 0.85,
          analyzedAt: call.createdAt,
        } : undefined,
      };
    });

    return NextResponse.json({
      success: true,
      calls: transformedCalls,
      count: transformedCalls.length,
    });
  } catch (error) {
    console.error("[Calls API] Error fetching calls:", error);
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
        calls: [],
      },
      { status: 500 }
    );
  }
}
