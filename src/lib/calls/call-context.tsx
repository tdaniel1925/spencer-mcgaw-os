"use client";

import { createContext, useContext, useState, useCallback, useEffect, useMemo } from "react";
import {
  CallRecord,
  CallAIAnalysis,
  CallCategory,
  CallStatus,
  CallNotification,
  CallActionRule,
  SuggestedCallAction,
  RawWebhookData,
} from "./types";

// Generate unique IDs
function generateId(): string {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

// Match caller to existing client (will integrate with real client database)
function matchClient(_callerPhone: string): { id: string; name: string } | null {
  // TODO: Integrate with real client database lookup
  return null;
}

// AI analysis simulation (in production, this would call OpenAI/Claude)
function generateAIAnalysis(transcript: string, callerPhone: string): CallAIAnalysis {
  const lowerTranscript = transcript.toLowerCase();

  // Determine category based on keywords
  let category: CallCategory = "other";
  if (lowerTranscript.includes("new client") || lowerTranscript.includes("looking for") || lowerTranscript.includes("services")) {
    category = "new_client_inquiry";
  } else if (lowerTranscript.includes("document") || lowerTranscript.includes("w-2") || lowerTranscript.includes("1099")) {
    category = "document_request";
  } else if (lowerTranscript.includes("appointment") || lowerTranscript.includes("schedule") || lowerTranscript.includes("meeting")) {
    category = "appointment_scheduling";
  } else if (lowerTranscript.includes("payment") || lowerTranscript.includes("invoice") || lowerTranscript.includes("bill")) {
    category = "payment_inquiry";
  } else if (lowerTranscript.includes("tax") || lowerTranscript.includes("return") || lowerTranscript.includes("refund")) {
    category = "tax_question";
  } else if (lowerTranscript.includes("status") || lowerTranscript.includes("update") || lowerTranscript.includes("where")) {
    category = "status_check";
  } else if (lowerTranscript.includes("urgent") || lowerTranscript.includes("asap") || lowerTranscript.includes("emergency")) {
    category = "urgent_matter";
  } else if (lowerTranscript.includes("complaint") || lowerTranscript.includes("unhappy") || lowerTranscript.includes("problem")) {
    category = "complaint";
  } else if (lowerTranscript.includes("follow") || lowerTranscript.includes("checking in")) {
    category = "follow_up";
  } else if (lowerTranscript.includes("voicemail") || lowerTranscript.includes("leave a message")) {
    category = "voicemail";
  }

  // Determine sentiment
  let sentiment: CallAIAnalysis["sentiment"] = "neutral";
  if (lowerTranscript.includes("thank") || lowerTranscript.includes("great") || lowerTranscript.includes("appreciate")) {
    sentiment = "positive";
  } else if (lowerTranscript.includes("frustrated") || lowerTranscript.includes("angry") || lowerTranscript.includes("upset")) {
    sentiment = "frustrated";
  } else if (lowerTranscript.includes("disappointed") || lowerTranscript.includes("unhappy")) {
    sentiment = "negative";
  }

  // Determine urgency
  let urgency: CallAIAnalysis["urgency"] = "medium";
  if (lowerTranscript.includes("urgent") || lowerTranscript.includes("asap") || lowerTranscript.includes("immediately")) {
    urgency = "urgent";
  } else if (lowerTranscript.includes("soon") || lowerTranscript.includes("deadline")) {
    urgency = "high";
  } else if (lowerTranscript.includes("whenever") || lowerTranscript.includes("no rush")) {
    urgency = "low";
  }

  // Generate suggested actions based on category
  const suggestedActions: SuggestedCallAction[] = [];

  if (category === "new_client_inquiry") {
    suggestedActions.push(
      { id: generateId(), type: "call_back", label: "Call back", description: "Return call to discuss services", priority: "high", autoGenerated: true },
      { id: generateId(), type: "send_email", label: "Send welcome email", description: "Send welcome packet and service information", priority: "medium", autoGenerated: true },
      { id: generateId(), type: "schedule_appointment", label: "Schedule consultation", description: "Set up initial consultation meeting", priority: "high", autoGenerated: true }
    );
  } else if (category === "document_request") {
    suggestedActions.push(
      { id: generateId(), type: "send_documents", label: "Send documents", description: "Send requested documents to client", priority: "high", autoGenerated: true },
      { id: generateId(), type: "create_task", label: "Create task", description: "Add to task list for document preparation", priority: "medium", autoGenerated: true }
    );
  } else if (category === "appointment_scheduling") {
    suggestedActions.push(
      { id: generateId(), type: "schedule_appointment", label: "Schedule appointment", description: "Book meeting with client", priority: "high", autoGenerated: true },
      { id: generateId(), type: "send_email", label: "Send availability", description: "Email available time slots", priority: "medium", autoGenerated: true }
    );
  } else if (category === "payment_inquiry") {
    suggestedActions.push(
      { id: generateId(), type: "call_back", label: "Call back", description: "Discuss payment details", priority: "high", autoGenerated: true },
      { id: generateId(), type: "send_email", label: "Send invoice", description: "Email invoice or payment details", priority: "medium", autoGenerated: true }
    );
  } else if (category === "urgent_matter") {
    suggestedActions.push(
      { id: generateId(), type: "call_back", label: "Call back immediately", description: "Urgent: Return call ASAP", priority: "high", autoGenerated: true },
      { id: generateId(), type: "assign_to_user", label: "Assign to senior staff", description: "Escalate to senior team member", priority: "high", autoGenerated: true }
    );
  }

  // Always add common actions
  suggestedActions.push(
    { id: generateId(), type: "create_task", label: "Add to tasks", description: "Create a task for follow-up", priority: "low", autoGenerated: true },
    { id: generateId(), type: "set_follow_up", label: "Set follow-up", description: "Schedule a follow-up date", priority: "low", autoGenerated: true }
  );

  // Extract key information
  const questions = transcript.match(/[^.!?]*\?/g) || [];
  const amounts = transcript.match(/\$[\d,]+(?:\.\d{2})?/g) || [];
  const dates = transcript.match(/(?:january|february|march|april|may|june|july|august|september|october|november|december)\s+\d{1,2}(?:st|nd|rd|th)?(?:,?\s+\d{4})?/gi) || [];

  // Generate summary
  const summaries: Record<CallCategory, string> = {
    new_client_inquiry: "Potential new client inquiring about services",
    existing_client_question: "Existing client has questions",
    document_request: "Client requesting or discussing documents",
    appointment_scheduling: "Client wants to schedule an appointment",
    payment_inquiry: "Client calling about payment or billing",
    tax_question: "Client has tax-related questions",
    status_check: "Client checking on status of their case",
    complaint: "Client expressing concerns or complaints",
    urgent_matter: "Urgent matter requiring immediate attention",
    follow_up: "Follow-up call from previous conversation",
    voicemail: "Voicemail left by caller",
    wrong_number: "Wrong number - not a client",
    spam: "Spam or solicitation call",
    web_form: "Web form submission received",
    contact_request: "Contact request received",
    general_inquiry: "General inquiry or question",
    other: "General inquiry",
  };

  return {
    summary: summaries[category],
    keyPoints: [
      `Category: ${category.replace(/_/g, " ")}`,
      `Caller sentiment: ${sentiment}`,
      questions.length > 0 ? `Asked ${questions.length} question(s)` : "No direct questions",
      amounts.length > 0 ? `Mentioned amounts: ${amounts.join(", ")}` : "",
    ].filter(Boolean),
    category,
    sentiment,
    urgency,
    extractedInfo: {
      reason: summaries[category],
      questions: questions.slice(0, 3),
      mentionedAmounts: amounts,
      mentionedDates: dates,
    },
    suggestedActions,
    confidence: 0.85 + Math.random() * 0.1,
    analyzedAt: new Date(),
  };
}

// Parse raw webhook data (AI would handle any format)
function parseWebhookData(rawData: RawWebhookData): Partial<CallRecord> {
  // This simulates AI parsing any webhook format
  // In production, this would use OpenAI/Claude to understand the data structure

  // Try to extract common fields from various webhook formats
  const callerPhone =
    (rawData.caller_phone as string) ||
    (rawData.from as string) ||
    (rawData.phone as string) ||
    (rawData.callerNumber as string) ||
    ((rawData.caller as { phone?: string })?.phone) ||
    "Unknown";

  const callerName =
    (rawData.caller_name as string) ||
    (rawData.name as string) ||
    ((rawData.caller as { name?: string })?.name) ||
    undefined;

  const transcript =
    (rawData.transcript as string) ||
    (rawData.transcription as string) ||
    (rawData.text as string) ||
    ((rawData.call as { transcript?: string })?.transcript) ||
    "";

  const recordingUrl =
    (rawData.recording_url as string) ||
    (rawData.recordingUrl as string) ||
    (rawData.audio_url as string) ||
    ((rawData.recording as { url?: string })?.url) ||
    undefined;

  const duration =
    (rawData.duration as number) ||
    (rawData.call_duration as number) ||
    (rawData.length as number) ||
    ((rawData.call as { duration?: number })?.duration) ||
    0;

  const startTime =
    (rawData.started_at as string) ||
    (rawData.start_time as string) ||
    (rawData.timestamp as string) ||
    ((rawData.call as { started_at?: string })?.started_at) ||
    new Date().toISOString();

  const endTime =
    (rawData.ended_at as string) ||
    (rawData.end_time as string) ||
    ((rawData.call as { ended_at?: string })?.ended_at) ||
    undefined;

  // Try to detect source provider
  const sourceProvider =
    (rawData.source_provider as string) ||
    (rawData.provider as string) ||
    (rawData.platform as string) ||
    undefined;

  return {
    callerPhone,
    callerName,
    transcript,
    recordingUrl,
    durationSeconds: duration,
    callStartedAt: new Date(startTime),
    callEndedAt: endTime ? new Date(endTime) : undefined,
    direction: (rawData.direction as "inbound" | "outbound") || "inbound",
    sourceProvider,
    rawData,
  };
}

interface CallContextType {
  // Calls
  calls: CallRecord[];
  getCallById: (id: string) => CallRecord | undefined;
  getCallsByStatus: (status: CallStatus) => CallRecord[];
  getCallsByCategory: (category: CallCategory) => CallRecord[];
  getUnreviewedCount: () => number;

  // Call actions
  updateCallStatus: (callId: string, status: CallStatus) => void;
  assignCall: (callId: string, userId: string, userName: string) => void;
  addCallNote: (callId: string, note: string) => void;
  setFollowUp: (callId: string, date: Date) => void;
  archiveCall: (callId: string) => void;
  deleteCall: (callId: string) => void;

  // AI Action feedback
  updateActionFeedback: (callId: string, actionId: string, feedback: "approved" | "rejected") => void;

  // Webhook processing
  processWebhook: (rawData: RawWebhookData) => CallRecord;

  // Notifications
  notifications: CallNotification[];
  unreadNotificationCount: number;
  markNotificationRead: (notificationId: string) => void;
  dismissNotification: (notificationId: string) => void;
  clearAllNotifications: () => void;

  // Action rules
  actionRules: CallActionRule[];
  addActionRule: (rule: Omit<CallActionRule, "id" | "createdAt" | "updatedAt">) => void;
  updateActionRule: (ruleId: string, updates: Partial<CallActionRule>) => void;
  deleteActionRule: (ruleId: string) => void;
}

const CallContext = createContext<CallContextType | undefined>(undefined);

export function CallProvider({ children }: { children: React.ReactNode }) {
  const [calls, setCalls] = useState<CallRecord[]>([]);
  const [notifications, setNotifications] = useState<CallNotification[]>([]);
  const [actionRules, setActionRules] = useState<CallActionRule[]>([]);

  // Initialize with empty state - real data comes from webhooks
  useEffect(() => {
    // TODO: Load calls from database on mount
    // For now, start with empty state for webhook testing
    setCalls([]);
    setNotifications([]);
  }, []);

  // Get call by ID
  const getCallById = useCallback(
    (id: string) => calls.find(c => c.id === id),
    [calls]
  );

  // Get calls by status
  const getCallsByStatus = useCallback(
    (status: CallStatus) => calls.filter(c => c.status === status),
    [calls]
  );

  // Get calls by category
  const getCallsByCategory = useCallback(
    (category: CallCategory) => calls.filter(c => c.aiAnalysis?.category === category),
    [calls]
  );

  // Get unreviewed count
  const getUnreviewedCount = useCallback(
    () => calls.filter(c => c.status === "new" || c.status === "action_required").length,
    [calls]
  );

  // Update call status
  const updateCallStatus = useCallback((callId: string, status: CallStatus) => {
    setCalls(prev =>
      prev.map(c =>
        c.id === callId
          ? { ...c, status, updatedAt: new Date(), reviewedAt: status !== "new" ? new Date() : c.reviewedAt }
          : c
      )
    );
  }, []);

  // Assign call
  const assignCall = useCallback((callId: string, userId: string, userName: string) => {
    setCalls(prev =>
      prev.map(c =>
        c.id === callId
          ? { ...c, assignedTo: userId, assignedToName: userName, updatedAt: new Date() }
          : c
      )
    );
  }, []);

  // Add note to call
  const addCallNote = useCallback((callId: string, note: string) => {
    setCalls(prev =>
      prev.map(c =>
        c.id === callId
          ? { ...c, notes: c.notes ? `${c.notes}\n\n${note}` : note, updatedAt: new Date() }
          : c
      )
    );
  }, []);

  // Set follow-up date
  const setFollowUp = useCallback((callId: string, date: Date) => {
    setCalls(prev =>
      prev.map(c =>
        c.id === callId
          ? { ...c, followUpDate: date, status: "follow_up_scheduled", updatedAt: new Date() }
          : c
      )
    );
  }, []);

  // Archive call
  const archiveCall = useCallback((callId: string) => {
    setCalls(prev =>
      prev.map(c =>
        c.id === callId
          ? { ...c, status: "archived", updatedAt: new Date() }
          : c
      )
    );
  }, []);

  // Delete call
  const deleteCall = useCallback((callId: string) => {
    setCalls(prev => prev.filter(c => c.id !== callId));
    setNotifications(prev => prev.filter(n => n.callId !== callId));
  }, []);

  // Update AI action feedback (thumbs up/down)
  const updateActionFeedback = useCallback(
    (callId: string, actionId: string, feedback: "approved" | "rejected") => {
      setCalls(prev =>
        prev.map(c => {
          if (c.id !== callId || !c.aiAnalysis?.suggestedActions) return c;
          return {
            ...c,
            aiAnalysis: {
              ...c.aiAnalysis,
              suggestedActions: c.aiAnalysis.suggestedActions.map(action =>
                action.id === actionId
                  ? { ...action, userFeedback: feedback, feedbackAt: new Date() }
                  : action
              ),
            },
            updatedAt: new Date(),
          };
        })
      );
    },
    []
  );

  // Process incoming webhook
  const processWebhook = useCallback((rawData: RawWebhookData): CallRecord => {
    // Parse the raw webhook data
    const parsed = parseWebhookData(rawData);

    // Match to existing client
    const matchedClient = matchClient(parsed.callerPhone || "");

    // Generate AI analysis
    const aiAnalysis = generateAIAnalysis(
      parsed.transcript || "",
      parsed.callerPhone || ""
    );

    // Create call record
    const newCall: CallRecord = {
      id: generateId(),
      source: "phone_call" as const,
      sourceProvider: parsed.sourceProvider || undefined,
      callerPhone: parsed.callerPhone || "Unknown",
      callerName: parsed.callerName || matchedClient?.name,
      callerEmail: undefined,
      callStartedAt: parsed.callStartedAt || new Date(),
      callEndedAt: parsed.callEndedAt,
      durationSeconds: parsed.durationSeconds || 0,
      direction: parsed.direction || "inbound",
      recordingUrl: parsed.recordingUrl,
      transcript: parsed.transcript,
      aiAnalysis,
      matchedClientId: matchedClient?.id,
      matchedClientName: matchedClient?.name,
      addedToClientRecord: !!matchedClient,
      status: aiAnalysis.urgency === "urgent" ? "action_required" : "new",
      createdAt: new Date(),
      updatedAt: new Date(),
      rawData,
    };

    // Add to calls
    setCalls(prev => [newCall, ...prev]);

    // Create notification
    const notification: CallNotification = {
      id: generateId(),
      callId: newCall.id,
      title: aiAnalysis.urgency === "urgent" ? "Urgent Call Received" : "New Call Received",
      message: aiAnalysis.summary,
      callerName: newCall.callerName,
      callerPhone: newCall.callerPhone,
      category: aiAnalysis.category,
      urgency: aiAnalysis.urgency,
      createdAt: new Date(),
      read: false,
      dismissed: false,
    };
    setNotifications(prev => [notification, ...prev]);

    return newCall;
  }, []);

  // Notification count - memoized
  const unreadNotificationCount = useMemo(
    () => notifications.filter(n => !n.read && !n.dismissed).length,
    [notifications]
  );

  // Mark notification as read
  const markNotificationRead = useCallback((notificationId: string) => {
    setNotifications(prev =>
      prev.map(n => (n.id === notificationId ? { ...n, read: true } : n))
    );
  }, []);

  // Dismiss notification
  const dismissNotification = useCallback((notificationId: string) => {
    setNotifications(prev =>
      prev.map(n => (n.id === notificationId ? { ...n, dismissed: true } : n))
    );
  }, []);

  // Clear all notifications
  const clearAllNotifications = useCallback(() => {
    setNotifications(prev => prev.map(n => ({ ...n, read: true, dismissed: true })));
  }, []);

  // Add action rule
  const addActionRule = useCallback(
    (rule: Omit<CallActionRule, "id" | "createdAt" | "updatedAt">) => {
      const newRule: CallActionRule = {
        ...rule,
        id: generateId(),
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      setActionRules(prev => [...prev, newRule]);
    },
    []
  );

  // Update action rule
  const updateActionRule = useCallback((ruleId: string, updates: Partial<CallActionRule>) => {
    setActionRules(prev =>
      prev.map(r => (r.id === ruleId ? { ...r, ...updates, updatedAt: new Date() } : r))
    );
  }, []);

  // Delete action rule
  const deleteActionRule = useCallback((ruleId: string) => {
    setActionRules(prev => prev.filter(r => r.id !== ruleId));
  }, []);

  // Memoize context value to prevent unnecessary re-renders
  const contextValue = useMemo(
    () => ({
      calls,
      getCallById,
      getCallsByStatus,
      getCallsByCategory,
      getUnreviewedCount,
      updateCallStatus,
      assignCall,
      addCallNote,
      setFollowUp,
      archiveCall,
      deleteCall,
      updateActionFeedback,
      processWebhook,
      notifications,
      unreadNotificationCount,
      markNotificationRead,
      dismissNotification,
      clearAllNotifications,
      actionRules,
      addActionRule,
      updateActionRule,
      deleteActionRule,
    }),
    [
      calls,
      getCallById,
      getCallsByStatus,
      getCallsByCategory,
      getUnreviewedCount,
      updateCallStatus,
      assignCall,
      addCallNote,
      setFollowUp,
      archiveCall,
      deleteCall,
      updateActionFeedback,
      processWebhook,
      notifications,
      unreadNotificationCount,
      markNotificationRead,
      dismissNotification,
      clearAllNotifications,
      actionRules,
      addActionRule,
      updateActionRule,
      deleteActionRule,
    ]
  );

  return (
    <CallContext.Provider value={contextValue}>
      {children}
    </CallContext.Provider>
  );
}

export function useCalls() {
  const context = useContext(CallContext);
  if (context === undefined) {
    throw new Error("useCalls must be used within a CallProvider");
  }
  return context;
}
