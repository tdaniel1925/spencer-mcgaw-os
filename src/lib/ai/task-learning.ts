/**
 * AI Task Learning System
 *
 * This module tracks how users interact with AI-suggested tasks
 * to enable continuous improvement of AI suggestions.
 *
 * Tracked events:
 * - Task assigned (who it was assigned to, for routing patterns)
 * - Task completed (was it useful, time to completion)
 * - Task dismissed (why wasn't it useful)
 * - Task edited (what did the user change)
 */

import { createClient } from "@/lib/supabase/server";

export type AIFeedbackAction =
  | "assigned"
  | "completed"
  | "dismissed"
  | "edited"
  | "claimed"
  | "routed";

export interface AITaskFeedback {
  taskId: string;
  action: AIFeedbackAction;
  userId: string;
  details?: {
    assignedTo?: string;
    editedFields?: string[];
    originalTitle?: string;
    newTitle?: string;
    routedToActionType?: string;
    dismissReason?: string;
    completionNotes?: string;
  };
}

/**
 * Check if a task was generated by AI
 */
export function isAIGeneratedTask(task: {
  source_type?: string | null;
  ai_extracted_data?: Record<string, unknown> | null;
  ai_confidence?: number | null;
}): boolean {
  // Check if it's from AI-analyzed phone call or email
  if (task.source_type === "phone_call" || task.source_type === "email") {
    return true;
  }

  // Check if it has AI extracted data
  if (task.ai_extracted_data && typeof task.ai_extracted_data === "object") {
    const data = task.ai_extracted_data as Record<string, unknown>;
    if (data.ai_suggested === true) {
      return true;
    }
  }

  // Check if it has AI confidence score
  if (task.ai_confidence && task.ai_confidence > 0) {
    return true;
  }

  return false;
}

/**
 * Log feedback for an AI-generated task
 * This should be called whenever a significant action is taken on an AI task
 */
export async function logAITaskFeedback(feedback: AITaskFeedback): Promise<void> {
  const supabase = await createClient();

  try {
    // Get the task to check if it's AI-generated and get context
    const { data: task, error: taskError } = await supabase
      .from("tasks")
      .select(`
        id,
        title,
        source_type,
        source_call_id,
        source_email_id,
        ai_extracted_data,
        ai_confidence,
        action_type_id,
        client_id,
        priority,
        created_at,
        status
      `)
      .eq("id", feedback.taskId)
      .single();

    if (taskError || !task) {
      console.error("[AI Learning] Task not found:", feedback.taskId);
      return;
    }

    // Only log feedback for AI-generated tasks
    if (!isAIGeneratedTask(task)) {
      console.log("[AI Learning] Not an AI task, skipping feedback:", feedback.taskId);
      return;
    }

    // Calculate time to action (from creation to now)
    const createdAt = new Date(task.created_at);
    const now = new Date();
    const timeToActionMs = now.getTime() - createdAt.getTime();
    const timeToActionMinutes = Math.round(timeToActionMs / (1000 * 60));

    // Determine if this action indicates the task was useful
    let wasUseful: boolean | null = null;
    if (feedback.action === "completed" || feedback.action === "routed") {
      wasUseful = true;
    } else if (feedback.action === "dismissed") {
      wasUseful = false;
    }

    // Get source context (caller info for calls, sender for emails)
    const aiData = (task.ai_extracted_data || {}) as Record<string, unknown>;
    const sourceContext = {
      source_type: task.source_type,
      category: aiData.category || null,
      urgency: aiData.urgency || null,
      caller_name: aiData.caller_name || (task.source_call_id ? "phone_call" : null),
    };

    // Insert into ai_training_feedback
    const { error: feedbackError } = await supabase
      .from("ai_training_feedback")
      .insert({
        task_id: feedback.taskId,
        original_action_type_id: task.action_type_id,
        feedback_text: JSON.stringify({
          action: feedback.action,
          time_to_action_minutes: timeToActionMinutes,
          source_context: sourceContext,
          ...feedback.details,
        }),
        was_correct: wasUseful,
        submitted_by: feedback.userId,
        feedback_type: `task_${feedback.action}`,
      });

    if (feedbackError) {
      console.error("[AI Learning] Failed to log feedback:", feedbackError);
      return;
    }

    console.log(
      `[AI Learning] Logged ${feedback.action} feedback for task ${feedback.taskId} ` +
      `(AI task, ${timeToActionMinutes}min to action, useful: ${wasUseful})`
    );

    // If this was an assignment, also log the routing pattern
    if (feedback.action === "assigned" && feedback.details?.assignedTo) {
      await logAssignmentPattern(supabase, task, feedback.details.assignedTo, feedback.userId);
    }
  } catch (error) {
    console.error("[AI Learning] Error logging feedback:", error);
  }
}

/**
 * Log assignment patterns for learning who handles what types of tasks
 */
async function logAssignmentPattern(
  supabase: Awaited<ReturnType<typeof createClient>>,
  task: {
    id: string;
    source_type?: string | null;
    client_id?: string | null;
    ai_extracted_data?: Record<string, unknown> | null;
  },
  assignedTo: string,
  assignedBy: string
): Promise<void> {
  const aiData = (task.ai_extracted_data || {}) as Record<string, unknown>;

  // Store assignment pattern in a metadata field for analytics
  // This can be used to suggest auto-assignments in the future
  const pattern = {
    task_id: task.id,
    source_type: task.source_type,
    category: aiData.category || null,
    urgency: aiData.urgency || null,
    client_id: task.client_id,
    assigned_to: assignedTo,
    assigned_by: assignedBy,
    recorded_at: new Date().toISOString(),
  };

  // Log to task activity for now - can be moved to dedicated table later
  await supabase.from("task_activity_log").insert({
    task_id: task.id,
    action: "ai_assignment_pattern",
    details: pattern,
    performed_by: assignedBy,
  });

  console.log(`[AI Learning] Recorded assignment pattern: ${task.source_type}/${aiData.category} -> ${assignedTo}`);
}

/**
 * Query helper to get suggested assignee based on historical patterns
 */
export async function getSuggestedAssignee(
  sourceType: string,
  category: string | null
): Promise<{ userId: string; confidence: number } | null> {
  const supabase = await createClient();

  try {
    // Query task activity log for assignment patterns
    const { data: patterns, error } = await supabase
      .from("task_activity_log")
      .select("details")
      .eq("action", "ai_assignment_pattern")
      .order("created_at", { ascending: false })
      .limit(100);

    if (error || !patterns || patterns.length === 0) {
      return null;
    }

    // Count assignments by user for matching source type/category
    const assignmentCounts: Record<string, number> = {};
    let totalMatches = 0;

    for (const pattern of patterns) {
      const details = pattern.details as Record<string, unknown>;
      if (details?.source_type === sourceType) {
        // Check category match (or null category matches anything)
        if (!category || details?.category === category || !details?.category) {
          const userId = details?.assigned_to as string;
          if (userId) {
            assignmentCounts[userId] = (assignmentCounts[userId] || 0) + 1;
            totalMatches++;
          }
        }
      }
    }

    if (totalMatches < 3) {
      // Not enough data to make a confident suggestion
      return null;
    }

    // Find the most common assignee
    let topUserId = "";
    let topCount = 0;
    for (const [userId, count] of Object.entries(assignmentCounts)) {
      if (count > topCount) {
        topCount = count;
        topUserId = userId;
      }
    }

    if (!topUserId) {
      return null;
    }

    // Calculate confidence based on how dominant this user is
    const confidence = Math.min(0.95, topCount / totalMatches);

    console.log(
      `[AI Learning] Suggested assignee for ${sourceType}/${category}: ${topUserId} ` +
      `(${topCount}/${totalMatches} assignments, ${Math.round(confidence * 100)}% confidence)`
    );

    return { userId: topUserId, confidence };
  } catch (error) {
    console.error("[AI Learning] Error getting suggested assignee:", error);
    return null;
  }
}

/**
 * Get AI task effectiveness stats
 */
export async function getAITaskStats(): Promise<{
  totalAITasks: number;
  completedTasks: number;
  dismissedTasks: number;
  pendingTasks: number;
  avgTimeToActionMinutes: number;
  completionRate: number;
  tasksBySource: Record<string, number>;
  tasksByCategory: Record<string, number>;
  recentFeedback: Array<{
    id: string;
    task_id: string;
    feedback_type: string;
    was_correct: boolean | null;
    created_at: string;
  }>;
}> {
  const supabase = await createClient();

  try {
    // Get all AI-generated tasks (phone_call or email source)
    const { data: aiTasks } = await supabase
      .from("tasks")
      .select("id, status, source_type, ai_extracted_data, created_at, completed_at")
      .in("source_type", ["phone_call", "email"]);

    if (!aiTasks || aiTasks.length === 0) {
      return {
        totalAITasks: 0,
        completedTasks: 0,
        dismissedTasks: 0,
        pendingTasks: 0,
        avgTimeToActionMinutes: 0,
        completionRate: 0,
        tasksBySource: {},
        tasksByCategory: {},
        recentFeedback: [],
      };
    }

    const completed = aiTasks.filter(t => t.status === "completed");
    const dismissed = aiTasks.filter(t => t.status === "dismissed" || t.status === "cancelled");
    const pending = aiTasks.filter(t => t.status === "pending" || t.status === "open" || t.status === "in_progress");

    // Calculate average time to completion
    let totalTimeMinutes = 0;
    let completedWithTime = 0;
    for (const task of completed) {
      if (task.completed_at && task.created_at) {
        const created = new Date(task.created_at);
        const completedAt = new Date(task.completed_at);
        const minutes = (completedAt.getTime() - created.getTime()) / (1000 * 60);
        totalTimeMinutes += minutes;
        completedWithTime++;
      }
    }

    const avgTime = completedWithTime > 0 ? Math.round(totalTimeMinutes / completedWithTime) : 0;

    // Group by source type
    const tasksBySource: Record<string, number> = {};
    for (const task of aiTasks) {
      const source = task.source_type || "unknown";
      tasksBySource[source] = (tasksBySource[source] || 0) + 1;
    }

    // Group by category (from ai_extracted_data)
    const tasksByCategory: Record<string, number> = {};
    for (const task of aiTasks) {
      const aiData = (task.ai_extracted_data || {}) as Record<string, unknown>;
      const category = (aiData.category as string) || "general";
      tasksByCategory[category] = (tasksByCategory[category] || 0) + 1;
    }

    // Get recent feedback from ai_training_feedback
    const { data: feedback } = await supabase
      .from("ai_training_feedback")
      .select("id, task_id, feedback_type, was_correct, created_at")
      .order("created_at", { ascending: false })
      .limit(20);

    // Calculate completion rate as percentage
    const totalActioned = completed.length + dismissed.length;
    const completionRate = totalActioned > 0
      ? Math.round((completed.length / totalActioned) * 100)
      : 0;

    return {
      totalAITasks: aiTasks.length,
      completedTasks: completed.length,
      dismissedTasks: dismissed.length,
      pendingTasks: pending.length,
      avgTimeToActionMinutes: avgTime,
      completionRate,
      tasksBySource,
      tasksByCategory,
      recentFeedback: feedback || [],
    };
  } catch (error) {
    console.error("[AI Learning] Error getting stats:", error);
    return {
      totalAITasks: 0,
      completedTasks: 0,
      dismissedTasks: 0,
      pendingTasks: 0,
      avgTimeToActionMinutes: 0,
      completionRate: 0,
      tasksBySource: {},
      tasksByCategory: {},
      recentFeedback: [],
    };
  }
}
